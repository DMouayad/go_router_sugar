import 'dart:io';
import './config_manager.dart';
import '../route_info.dart';

class CodeGenerator {
  final List<RouteInfo> routes;
  final Config config;

  CodeGenerator({required this.routes, required this.config});

  Future<void> generate() async {
    final buffer = StringBuffer();
    _writeHeader(buffer);
    _writeImports(buffer);
    _writeAppRouter(buffer);
    _writeRouteConstants(buffer);
    _writeNavigationAPI(buffer);
    _writeExtensions(buffer);

    final file = File(config.outputPath);
    await file.create(recursive: true);
    await file.writeAsString(buffer.toString());
  }

  void _writeHeader(StringBuffer buffer) {
    buffer.writeln('// üç¨ GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln(
        '// Generated by Go Router Sugar - The Simplest Flutter Routing Ever!');
    buffer.writeln('//');
    buffer
        .writeln('// üéØ This file provides a complete routing solution with:');
    buffer.writeln('//   ‚úÖ Type-safe navigation');
    buffer.writeln('//   ‚úÖ Zero string-based routing');
    buffer.writeln('//   ‚úÖ Full parameter validation');
    buffer.writeln('//   ‚úÖ Beautiful IntelliSense support');
    buffer.writeln('//');
    buffer.writeln('// üìñ Usage:');
    buffer.writeln('//   Navigate.toHome();');
    buffer.writeln(
        '//   Navigate.toProduct(id: "123", category: "electronics");');
    buffer.writeln('//   context.goToHome();');
    buffer.writeln('//   context.goToProduct(id: "123");');
    buffer.writeln('//');
    buffer.writeln(
        '// üöÄ Say goodbye to: context.go("/products/123?category=electronics")');
    buffer.writeln(
        '// üéâ Say hello to:   Navigate.toProduct(id: "123", category: "electronics")');
    buffer.writeln();
  }

  void _writeImports(StringBuffer buffer) {
    buffer.writeln("import 'package:flutter/material.dart';");
    buffer.writeln("import 'package:go_router_sugar/go_router_sugar.dart';");
    buffer.writeln();

    // Group imports by directory for better organization
    final imports = routes.map((route) => route.importPath).toSet().toList()
      ..sort();
    for (final import in imports) {
      buffer.writeln("import '$import';");
    }
    buffer.writeln();
  }

  void _writeAppRouter(StringBuffer buffer) {
    buffer.writeln('/// üç¨ Your App\'s Complete Routing Configuration');
    buffer.writeln('///');
    buffer.writeln(
        '/// Generated from your page files with zero configuration required.');
    buffer.writeln(
        '/// Just add this to your MaterialApp.router(routerConfig: AppRouter.router)');
    buffer.writeln('class AppRouter {');
    buffer.writeln(
        '  AppRouter._(); // Private constructor - use static router instance');
    buffer.writeln();
    buffer.writeln('  /// üéØ The complete GoRouter configuration for your app');
    buffer.writeln('  ///');
    buffer.writeln(
        '  /// Includes ${routes.length} route${routes.length == 1 ? '' : 's'} with full type safety and parameter validation.');
    buffer.writeln('  static final GoRouter router = GoRouter(');
    buffer.writeln("    initialLocation: '${config.initialRoute}',");
    buffer.writeln('    routes: [');

    for (final route in routes) {
      _writeGoRoute(buffer, route);
    }

    buffer.writeln('    ],');
    buffer.writeln('  );');
    buffer.writeln('}');
    buffer.writeln();
  }

  void _writeRouteConstants(StringBuffer buffer) {
    buffer.writeln('/// üóÇÔ∏è Route Path Constants');
    buffer.writeln('///');
    buffer.writeln('/// Use these constants instead of hardcoded strings.');
    buffer.writeln(
        '/// Example: context.go(Routes.home) instead of context.go("/home")');
    buffer.writeln('class Routes {');
    buffer.writeln('  Routes._(); // Private constructor');
    buffer.writeln();

    for (final route in routes) {
      final routeName = _routeToConstantName(route.routePath);
      final comment = _getRouteDescription(route);
      buffer.writeln('  /// $comment');
      buffer
          .writeln("  static const String $routeName = '${route.routePath}';");
      buffer.writeln();
    }

    buffer.writeln('  /// üìã All available routes in your app');
    buffer.writeln('  static const List<String> all = [');
    for (final route in routes) {
      final routeName = _routeToConstantName(route.routePath);
      buffer.writeln('    $routeName,');
    }
    buffer.writeln('  ];');
    buffer.writeln('}');
    buffer.writeln();
  }

  void _writeNavigationAPI(StringBuffer buffer) {
    buffer.writeln('/// üöÄ Type-Safe Navigation API');
    buffer.writeln('///');
    buffer.writeln(
        '/// Navigate to any page with full type safety and parameter validation.');
    buffer.writeln('/// No more string-based routing or runtime errors!');
    buffer.writeln('///');
    buffer.writeln('/// Example:');
    buffer.writeln('///   Navigate.toHome();');
    buffer.writeln(
        '///   Navigate.toProduct(id: "123", category: "electronics");');
    buffer.writeln('class Navigate {');
    buffer.writeln('  Navigate._(); // Private constructor');
    buffer.writeln();
    buffer.writeln(
        '  /// üß≠ The global navigator key for programmatic navigation');
    buffer.writeln(
        '  static final GlobalKey<NavigatorState> _navigatorKey = GlobalKey<NavigatorState>();');
    buffer.writeln();
    buffer
        .writeln('  /// Access to the navigator key (for advanced use cases)');
    buffer.writeln(
        '  static GlobalKey<NavigatorState> get navigatorKey => _navigatorKey;');
    buffer.writeln();

    for (final route in routes) {
      _writeNavigationMethod(buffer, route);
    }

    buffer.writeln('}');
    buffer.writeln();
  }

  void _writeExtensions(StringBuffer buffer) {
    buffer.writeln('/// üéØ BuildContext Extensions for Fluent Navigation');
    buffer.writeln('///');
    buffer.writeln(
        '/// Use these extension methods for more idiomatic Flutter navigation.');
    buffer.writeln(
        '/// Example: context.goToHome() instead of Navigate.toHome()');
    buffer.writeln('extension GoRouterSugarNavigation on BuildContext {');
    buffer.writeln();

    for (final route in routes) {
      _writeExtensionMethod(buffer, route);
    }

    buffer.writeln('}');
  }

  void _writeGoRoute(StringBuffer buffer, RouteInfo route) {
    // Ensure route path starts with "/" and validate format
    String routePath = route.routePath;
    if (!routePath.startsWith('/')) {
      routePath = '/$routePath';
    }

    // Additional validation for route path format
    if (routePath.isEmpty || routePath == '//' || routePath.contains('//')) {
      print(
          '‚ö†Ô∏è Warning: Invalid route path format: "${route.routePath}" -> normalized to "/$routePath"');
      routePath = routePath.replaceAll('//', '/');
      if (routePath.isEmpty || routePath == '/') {
        routePath = '/';
      }
    }

    final routeParams = routePath
        .split('/')
        .where((s) => s.startsWith(':'))
        .map((s) => s.substring(1));

    buffer.writeln('      GoRoute(');
    buffer.writeln('        path: \'$routePath\',');
    buffer.writeln('        builder: (context, state) {');

    if (routeParams.isEmpty) {
      buffer.writeln('          return const ${route.className}();');
    } else {
      final paramMappings = <String>[];
      for (final paramName in routeParams) {
        // Check if this parameter exists in route.parameters
        final hasParam = route.parameters.any((p) => p.name == paramName);
        if (hasParam) {
          // Default to String type, could be enhanced later
          paramMappings
              .add('$paramName: state.pathParameters[\'$paramName\'] ?? \'\'');
        } else {
          print(
              '‚ö†Ô∏è Warning: Route \'$routePath\' has param \':$paramName\' but it\'s not in the ${route.className} constructor.');
          // Still provide the parameter to avoid compilation errors
          paramMappings
              .add('$paramName: state.pathParameters[\'$paramName\'] ?? \'\'');
        }
      }

      if (paramMappings.isNotEmpty) {
        buffer.writeln(
            '          return ${route.className}(${paramMappings.join(', ')});');
      } else {
        buffer.writeln('          return const ${route.className}();');
      }
    }
    buffer.writeln('        },');
    buffer.writeln('      ),');
  }

  String _routeToConstantName(String routePath) {
    if (routePath == '/') return 'home';

    final cleanRoute =
        routePath.startsWith('/') ? routePath.substring(1) : routePath;
    final parts = cleanRoute.split('/').map((part) {
      if (part.startsWith(':')) {
        return _capitalize(part.substring(1)); // :id becomes Id
      }
      return _capitalize(part);
    }).toList();

    if (parts.isEmpty) return 'home';

    // Convert to lowerCamelCase
    final result = parts.first.toLowerCase() +
        parts.skip(1).map((part) => _capitalize(part)).join('');

    return result.isEmpty ? 'home' : result;
  }

  String _getRouteDescription(RouteInfo route) {
    final className = route.className.replaceAll('Page', '');
    if (route.routePath == '/')
      return 'üè† Home page - Your app\'s starting point';

    if (route.parameters.isNotEmpty) {
      final paramDesc =
          route.parameters.map((p) => 'specific ${p.name}').join(' and ');
      return 'üîç $className page for $paramDesc';
    }

    return 'üìÑ $className page';
  }

  String _routeToMethodName(String routePath) {
    if (routePath == '/') return 'toHome';

    // Handle common patterns for better method names
    final cleanRoute =
        routePath.startsWith('/') ? routePath.substring(1) : routePath;

    // Special handling for common patterns
    if (cleanRoute.contains('/list')) {
      final base = cleanRoute.replaceAll('/list', '');
      return 'to${_capitalize(base)}List';
    }

    if (cleanRoute.contains('/:')) {
      // For routes like "products/:id", generate "toProduct" (singular)
      final parts = cleanRoute.split('/');
      final baseParts = parts.where((part) => !part.startsWith(':')).toList();
      if (baseParts.isNotEmpty) {
        final base = baseParts.join('_');
        return 'to${_capitalize(_singularize(base))}';
      }
    }

    // Default handling
    final parts = cleanRoute
        .split('/')
        .where((part) => part.isNotEmpty && !part.startsWith(':'))
        .map((part) => _capitalize(part))
        .toList();

    if (parts.isEmpty) return 'toHome';
    return 'to${parts.join('')}';
  }

  String _capitalize(String word) {
    if (word.isEmpty) return word;
    return word[0].toUpperCase() + word.substring(1);
  }

  String _singularize(String word) {
    // Simple singularization - can be enhanced
    if (word.endsWith('s') && word.length > 1) {
      return word.substring(0, word.length - 1);
    }
    return word;
  }

  void _writeNavigationMethod(StringBuffer buffer, RouteInfo route) {
    final methodName = _routeToMethodName(route.routePath);
    final description = _getRouteDescription(route);
    final hasParams = route.parameters.isNotEmpty;

    buffer.writeln('  /// $description');
    if (hasParams) {
      buffer.writeln('  ///');
      for (final param in route.parameters) {
        buffer.writeln(
            '  /// [${param.name}] - ${param.isRequired ? 'Required' : 'Optional'} parameter');
      }
    }
    buffer.write('  static void $methodName(');

    if (hasParams) {
      buffer.writeln('{');
      for (final param in route.parameters) {
        final required = param.isRequired ? 'required ' : '';
        buffer.writeln(
            '    ${required}String${param.isRequired ? '' : '?'} ${param.name},');
      }
      buffer.write('  }');
    }

    buffer.writeln(') {');
    buffer.writeln('    final context = _navigatorKey.currentContext;');
    buffer.writeln('    if (context == null) {');
    buffer.writeln(
        '      throw StateError(\'Navigator context is null. Make sure AppRouter.router is used in MaterialApp.router\');');
    buffer.writeln('    }');

    if (hasParams) {
      // Build the route with parameters
      final routeParts = route.routePath.split('/');
      buffer.write('    final path = \'');
      for (int i = 0; i < routeParts.length; i++) {
        final part = routeParts[i];
        if (part.startsWith(':')) {
          final paramName = part.substring(1);
          buffer.write('\$$paramName');
        } else {
          buffer.write(part);
        }
        if (i < routeParts.length - 1) buffer.write('/');
      }
      buffer.writeln('\';');
      buffer.writeln('    context.go(path);');
    } else {
      buffer.writeln('    context.go(\'${route.routePath}\');');
    }

    buffer.writeln('  }');
    buffer.writeln();
  }

  void _writeExtensionMethod(StringBuffer buffer, RouteInfo route) {
    final methodName = _routeToMethodName(route.routePath);
    final goMethodName = methodName.replaceFirst('to', 'goTo');
    final description = _getRouteDescription(route);
    final hasParams = route.parameters.isNotEmpty;

    buffer.writeln('  /// $description');
    buffer.write('  void $goMethodName(');

    if (hasParams) {
      buffer.writeln('{');
      for (final param in route.parameters) {
        final required = param.isRequired ? 'required ' : '';
        buffer.writeln(
            '    ${required}String${param.isRequired ? '' : '?'} ${param.name},');
      }
      buffer.write('  }');
    }

    buffer.write(') => Navigate.$methodName(');
    if (hasParams) {
      final paramList =
          route.parameters.map((p) => '${p.name}: ${p.name}').join(', ');
      buffer.write(paramList);
    }
    buffer.writeln(');');
    buffer.writeln();
  }
}
