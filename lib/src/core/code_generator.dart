import 'dart:io';
import './config_manager.dart';
import '../route_info.dart';

class CodeGenerator {
  final List<RouteInfo> routes;
  final Config config;

  CodeGenerator({required this.routes, required this.config});

  Future<void> generate() async {
    final buffer = StringBuffer();
    _writeHeader(buffer);
    _writeImports(buffer);
    _writeRouterClass(buffer);
    
    final file = File(config.outputPath);
    await file.create(recursive: true);
    await file.writeAsString(buffer.toString());
  }

  void _writeHeader(StringBuffer buffer) {
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by go_router_sugar üç¨');
    buffer.writeln();
  }

  void _writeImports(StringBuffer buffer) {
    buffer.writeln("import 'package:flutter/material.dart';");
    buffer.writeln("import 'package:go_router/go_router.dart';");
    for (final route in routes) {
      buffer.writeln("import '${route.importPath}';");
    }
    buffer.writeln();
  }

  void _writeRouterClass(StringBuffer buffer) {
    buffer.writeln('class AppRouter {');
    buffer.writeln('  static final GoRouter router = GoRouter(');
    buffer.writeln("    initialLocation: '${config.initialRoute}',");
    buffer.writeln('    routes: [');
    for (final route in routes) {
      _writeGoRoute(buffer, route);
    }
    buffer.writeln('    ],');
    buffer.writeln('  );');
    buffer.writeln('}');
  }
  
  void _writeGoRoute(StringBuffer buffer, RouteInfo route) {
    // Ensure route path starts with "/" and validate format
    String routePath = route.routePath;
    if (!routePath.startsWith('/')) {
      routePath = '/$routePath';
    }
    
    // Additional validation for route path format
    if (routePath.isEmpty || routePath == '//' || routePath.contains('//')) {
      print('‚ö†Ô∏è Warning: Invalid route path format: "${route.routePath}" -> normalized to "/$routePath"');
      routePath = routePath.replaceAll('//', '/');
      if (routePath.isEmpty || routePath == '/') {
        routePath = '/';
      }
    }
    
    final routeParams = routePath.split('/').where((s) => s.startsWith(':')).map((s) => s.substring(1));
    
    buffer.writeln('      GoRoute(');
    buffer.writeln('        path: \'$routePath\',');
    buffer.writeln('        builder: (context, state) {');
    
    if (routeParams.isEmpty) {
      buffer.writeln('          return const ${route.className}();');
    } else {
      final paramMappings = <String>[];
      for (final paramName in routeParams) {
        // Check if this parameter exists in route.parameters
        final hasParam = route.parameters.any((p) => p.name == paramName);
        if (hasParam) {
          // Default to String type, could be enhanced later
          paramMappings.add('$paramName: state.pathParameters[\'$paramName\'] ?? \'\'');
        } else {
           print('‚ö†Ô∏è Warning: Route \'$routePath\' has param \':$paramName\' but it\'s not in the ${route.className} constructor.');
           // Still provide the parameter to avoid compilation errors
           paramMappings.add('$paramName: state.pathParameters[\'$paramName\'] ?? \'\'');
        }
      }
      
      if (paramMappings.isNotEmpty) {
        buffer.writeln('          return ${route.className}(${paramMappings.join(', ')});');
      } else {
        buffer.writeln('          return const ${route.className}();');
      }
    }
    buffer.writeln('        },');
    buffer.writeln('      ),');
  }
}