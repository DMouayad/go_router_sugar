import 'dart:async';
import 'package:build/build.dart';
import 'package:glob/glob.dart';
import 'route_info.dart';

/// Factory function that creates the RouteBuilder instance
/// This is referenced in build.yaml
Builder routeBuilder(BuilderOptions options) => RouteBuilder(options);

/// The main builder class that generates routing code
///
/// This builder scans the specified pages directory and generates:
/// 1. GoRouter configuration with all discovered routes
/// 2. Type-safe navigation helper methods
/// 3. Route constants for easy reference
class RouteBuilder implements Builder {
  /// Creates a new RouteBuilder with the specified [options].
  RouteBuilder(this.options);

  /// The build options containing configuration for the builder.
  final BuilderOptions options;

  @override
  Map<String, List<String>> get buildExtensions {
    // Try to get output file from options, fallback to default
    final outputFile = options.config['output_file'] as String? ?? 'lib/app_router.g.dart';
    return {
      'lib/\$lib\$': [outputFile]
    };
  }

  @override
  Future<void> build(BuildStep buildStep) async {
    try {
      // Get configuration from build.yaml or use defaults
      final config = _BuildConfig.fromOptions(options);

      // Create the output asset ID
      final outputId = AssetId(buildStep.inputId.package, config.outputFile);

      // Discover all page files in the specified directory
      final routeInfos =
          await _discoverRoutes(buildStep, config.pagesDirectory);

      if (routeInfos.isEmpty) {
        log.warning('No page files found in ${config.pagesDirectory}. '
            'Make sure your page files end with "_page.dart"');
        return;
      }

      // Generate the complete router code
      final generatedCode =
          _generateRouterCode(routeInfos, config, buildStep.inputId.package);

      // Write the generated code to the output file
      await buildStep.writeAsString(outputId, generatedCode);

      log.info('Generated router with ${routeInfos.length} routes');
    } catch (e, stackTrace) {
      log.severe('Error generating routes: $e', e, stackTrace);
      rethrow;
    }
  }

  /// Discovers all page files and converts them to RouteInfo objects
  Future<List<RouteInfo>> _discoverRoutes(
      BuildStep buildStep, String pagesDirectory) async {
    final pageFiles =
        buildStep.findAssets(Glob('$pagesDirectory/**_page.dart'));
    final routeInfos = <RouteInfo>[];

    await for (final pageAsset in pageFiles) {
      try {
        final routeInfo = RouteInfo.fromPath(pageAsset.path, pagesDirectory);
        routeInfos.add(routeInfo);
      } on Exception catch (e) {
        log.warning('Skipping invalid page file ${pageAsset.path}: $e');
      }
    }

    // Sort routes by path for consistent generation
    routeInfos.sort((a, b) => a.routePath.compareTo(b.routePath));

    return routeInfos;
  }

  /// Generates the complete router code including imports, routes, and helpers
  String _generateRouterCode(
      List<RouteInfo> routes, _BuildConfig config, String packageName) {
    final buffer = StringBuffer();

    // Generate file header with imports
    _writeHeader(buffer, routes, packageName);

    // Generate route constants
    _writeRouteConstants(buffer, routes);

    // Generate the main router class
    _writeRouterClass(buffer, routes, config);

    // Generate navigation helpers if enabled
    if (config.generateNavigationHelpers) {
      _writeNavigationHelpers(buffer, routes, config);
    }

    return buffer.toString();
  }

  /// Writes the file header with necessary imports
  void _writeHeader(
      StringBuffer buffer, List<RouteInfo> routes, String packageName) {
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by go_router_sugar');
    buffer.writeln(
        '// ignore_for_file: type=lint, unused_import, directives_ordering');
    buffer.writeln();

    // Core Flutter and routing imports
    buffer.writeln("import 'package:flutter/material.dart';");
    buffer.writeln("import 'package:go_router/go_router.dart';");
    buffer.writeln();

    // Import all page files
    for (final route in routes) {
      buffer.writeln("import 'package:$packageName/${route.importPath}';");
    }
    buffer.writeln();
  }

  /// Generates route constants for easy reference
  void _writeRouteConstants(StringBuffer buffer, List<RouteInfo> routes) {
    buffer.writeln('/// Generated route constants');
    buffer.writeln('abstract class Routes {');

    for (final route in routes) {
      final constantName = _routeToConstantName(route.routePath);
      buffer.writeln('  /// Route: ${route.routePath}');
      buffer.writeln(
          '  static const String $constantName = \'${route.routePath}\';');
      buffer.writeln();
    }

    buffer.writeln('}');
    buffer.writeln();
  }

  /// Generates the main router class with GoRouter configuration
  void _writeRouterClass(
      StringBuffer buffer, List<RouteInfo> routes, _BuildConfig config) {
    buffer.writeln('/// Auto-generated router configuration');
    buffer.writeln('class ${config.routerClassName} {');
    buffer.writeln('  ${config.routerClassName}._();');
    buffer.writeln();
    buffer.writeln('  /// The configured GoRouter instance');
    buffer.writeln('  static final GoRouter instance = GoRouter(');
    buffer.writeln('    routes: <RouteBase>[');

    // Generate all routes
    for (final route in routes) {
      _writeGoRoute(buffer, route);
    }

    buffer.writeln('    ],');
    buffer.writeln('  );');
    buffer.writeln();
    buffer.writeln('    /// Access the router configuration');
    buffer.writeln('    static GoRouter get router => instance;');
    buffer.writeln('}');
    buffer.writeln();
  }

  /// Generates a single GoRoute
  void _writeGoRoute(StringBuffer buffer, RouteInfo route) {
    buffer.writeln('      GoRoute(');
    buffer.writeln('        path: \'${route.routePath}\',');
    buffer.writeln(
        '        builder: (BuildContext context, GoRouterState state) {');

    if (route.hasDynamicParams) {
      // Generate constructor call with parameters
      final paramAssignments = route.parameters.map((param) {
        return '${param.name}: state.pathParameters[\'${param.name}\'] ?? \'\'';
      }).join(',\n            ');

      buffer.writeln('          return ${route.className}(');
      buffer.writeln('            $paramAssignments,');
      buffer.writeln('          );');
    } else {
      // Simple constructor call
      buffer.writeln('          return const ${route.className}();');
    }

    buffer.writeln('        },');
    buffer.writeln('      ),');
  }

  /// Generates type-safe navigation helper methods
  void _writeNavigationHelpers(
      StringBuffer buffer, List<RouteInfo> routes, _BuildConfig config) {
    buffer.writeln('/// Type-safe navigation helpers');
    buffer
        .writeln('extension ${config.routerClassName}Navigation on GoRouter {');

    for (final route in routes) {
      _writeNavigationMethod(buffer, route, isGo: true);
      _writeNavigationMethod(buffer, route, isGo: false);
    }

    buffer.writeln('}');
    buffer.writeln();

    // Also create a convenience class for static access
    buffer.writeln('/// Static navigation helpers');
    buffer.writeln('class Navigate {');
    buffer.writeln('  Navigate._();');
    buffer.writeln();

    for (final route in routes) {
      _writeStaticNavigationMethod(buffer, route, isGo: true);
      _writeStaticNavigationMethod(buffer, route, isGo: false);
    }

    buffer.writeln('}');
  }

  /// Writes a navigation method for the GoRouter extension
  void _writeNavigationMethod(StringBuffer buffer, RouteInfo route,
      {required bool isGo}) {
    final methodPrefix = isGo ? 'goTo' : 'pushTo';
    final routerMethod = isGo ? 'go' : 'push';
    final methodName = '$methodPrefix${_routeToMethodName(route.routePath)}';

    // Generate method signature
    if (route.hasDynamicParams) {
      final paramList = route.parameters.map((param) {
        return 'required String ${param.name}';
      }).join(', ');

      buffer.writeln('  /// Navigate to ${route.routePath}');
      buffer.writeln('  void $methodName({$paramList}) {');

      // Build the path with parameter substitution
      String pathBuilding = '\'${route.routePath}\'';
      for (final param in route.parameters) {
        pathBuilding =
            '$pathBuilding.replaceAll(\':${param.name}\', ${param.name})';
      }

      buffer.writeln('    $routerMethod($pathBuilding);');
    } else {
      buffer.writeln('  /// Navigate to ${route.routePath}');
      buffer.writeln('  void $methodName() {');
      buffer.writeln('    $routerMethod(\'${route.routePath}\');');
    }

    buffer.writeln('  }');
    buffer.writeln();
  }

  /// Writes a static navigation method
  void _writeStaticNavigationMethod(StringBuffer buffer, RouteInfo route,
      {required bool isGo}) {
    final methodPrefix = isGo ? 'goTo' : 'pushTo';
    final routerMethod = isGo ? 'go' : 'push';
    final methodName = '$methodPrefix${_routeToMethodName(route.routePath)}';

    if (route.hasDynamicParams) {
      final paramList = route.parameters.map((param) {
        return 'required String ${param.name}';
      }).join(', ');

      buffer.writeln('  /// Navigate to ${route.routePath}');
      buffer.writeln('  static void $methodName({$paramList}) {');

      String pathBuilding = '\'${route.routePath}\'';
      for (final param in route.parameters) {
        pathBuilding =
            '$pathBuilding.replaceAll(\':${param.name}\', ${param.name})';
      }

      buffer.writeln('    AppRouter.instance.$routerMethod($pathBuilding);');
    } else {
      buffer.writeln('  /// Navigate to ${route.routePath}');
      buffer.writeln('  static void $methodName() {');
      buffer.writeln(
          '    AppRouter.instance.$routerMethod(\'${route.routePath}\');');
    }

    buffer.writeln('  }');
    buffer.writeln();
  }

  /// Converts a route path to a constant name
  /// Example: '/products/:id' -> 'productsId'
  String _routeToConstantName(String routePath) {
    return routePath
        .replaceAll('/', '')
        .replaceAll(':', '')
        .split(RegExp(r'[^a-zA-Z0-9]'))
        .where((part) => part.isNotEmpty)
        .map((part) => part[0].toLowerCase() + part.substring(1))
        .join();
  }

  /// Converts a route path to a method name
  /// Example: '/products/:id' -> 'ProductsId'
  String _routeToMethodName(String routePath) {
    return routePath
        .replaceAll('/', '')
        .replaceAll(':', '')
        .split(RegExp(r'[^a-zA-Z0-9]'))
        .where((part) => part.isNotEmpty)
        .map((part) => part[0].toUpperCase() + part.substring(1))
        .join();
  }
}

/// Internal configuration class for the builder
class _BuildConfig {
  /// Creates a new build configuration.
  const _BuildConfig({
    required this.pagesDirectory,
    required this.generateNavigationHelpers,
    required this.routerClassName,
    required this.outputFile,
  });

  /// Creates a build configuration from builder options.
  factory _BuildConfig.fromOptions(BuilderOptions options) {
    final config = options.config;

    return _BuildConfig(
      pagesDirectory: config['pages_directory'] as String? ?? 'lib/pages',
      generateNavigationHelpers:
          config['generate_navigation_helpers'] as bool? ?? true,
      routerClassName: config['router_class_name'] as String? ?? 'AppRouter',
      outputFile: config['output_file'] as String? ?? 'lib/app_router.g.dart',
    );
  }

  /// The directory containing page files.
  final String pagesDirectory;

  /// Whether to generate navigation helper methods.
  final bool generateNavigationHelpers;

  /// The name of the generated router class.
  final String routerClassName;

  /// The output file path for generated code.
  final String outputFile;
}
